<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Shooter 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-weight: bold;
            font-size: 1.2em;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #00ff00;
            border-radius: 5px;
        }

        .hud-item {
            margin: 8px 0;
        }

        .hud-item span {
            color: #ffff00;
        }

        .weapon-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #ff0000;
            border-radius: 5px;
            z-index: 100;
        }

        .weapon-button {
            display: inline-block;
            padding: 8px 15px;
            margin-top: 10px;
            background: #333;
            border: 2px solid #00ff00;
            color: #00ff00;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            margin-right: 8px;
            transition: all 0.3s;
        }

        .weapon-button:hover {
            background: #00ff00;
            color: #000;
        }

        .weapon-button.active {
            background: #00ff00;
            color: #000;
        }

        .difficulty-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .difficulty-content {
            text-align: center;
        }

        .difficulty-content h1 {
            color: #00ff00;
            font-size: 3em;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #00ff00;
        }

        .difficulty-button {
            display: block;
            padding: 20px 40px;
            margin: 15px auto;
            font-size: 1.5em;
            background: #333;
            color: #00ff00;
            border: 2px solid #00ff00;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            width: 300px;
        }

        .difficulty-button:hover {
            background: #00ff00;
            color: #000;
            transform: scale(1.05);
        }

        .difficulty-label {
            color: #ffff00;
            font-size: 1.2em;
            margin-top: 30px;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        .game-over-content {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid #ff0000;
        }

        .game-over-content h1 {
            color: #ff0000;
            font-size: 3em;
            margin-bottom: 20px;
        }

        .game-over-content p {
            color: #00ff00;
            font-size: 1.5em;
            margin: 15px 0;
        }

        .game-over-content button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .game-over-content button:hover {
            background: #00cc00;
            transform: scale(1.05);
        }

        .controls-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            font-size: 0.9em;
            z-index: 100;
        }

        .controls-info p {
            margin: 5px 0;
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 200;
        }

        .crosshair::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 12px;
            background: #00ff00;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            box-shadow: 0 26px 0 #00ff00;
        }

        .crosshair::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 2px;
            background: #00ff00;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 26px 0 0 #00ff00;
        }

        .crosshair-center {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffff00;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 6px #ffff00;
        }
    </style>
</head>
<body>
    <div class="difficulty-screen" id="difficultyScreen">
        <div class="difficulty-content">
            <h1>‚öîÔ∏è ZOMBIE SHOOTER 3D ‚öîÔ∏è</h1>
            <p style="color: #00ff00; font-size: 1.3em; margin-bottom: 40px;">Escolha o N√≠vel de Dificuldade</p>
            <button class="difficulty-button" onclick="startGame('easy')">
                üü¢ F√ÅCIL
                <div class="difficulty-label">Menos zumbis, movimento lento</div>
            </button>
            <button class="difficulty-button" onclick="startGame('normal')">
                üü° NORMAL
                <div class="difficulty-label">Desafio moderado</div>
            </button>
            <button class="difficulty-button" onclick="startGame('hard')">
                üî¥ DIF√çCIL
                <div class="difficulty-label">Horda massiva, zumbis r√°pidos</div>
            </button>
        </div>
    </div>

    <div class="crosshair" id="crosshair">
        <div class="crosshair-center"></div>
    </div>

    <div class="hud" id="hud">
        <div class="hud-item">Vidas: <span id="lives">3</span> ‚ù§Ô∏è</div>
        <div class="hud-item">Pontos: <span id="score">0</span></div>
        <div class="hud-item">Zumbis: <span id="zombies">0</span></div>
        <div class="hud-item">Dificuldade: <span id="difficulty">NORMAL</span></div>
    </div>

    <div class="weapon-info" id="weaponInfo">
        <div>Arma Atual: <span id="weaponName">PISTOLA</span></div>
        <div style="margin-top: 10px; font-size: 0.9em;">
            <div>Muni√ß√£o: <span id="ammo">‚àû</span></div>
            <div>Granadas: <span id="grenades">‚àû</span></div>
        </div>
        <button class="weapon-button active" onclick="changeWeapon('pistol')">1 - PISTOLA</button>
        <button class="weapon-button" onclick="changeWeapon('bow')">2 - ARCO</button>
        <button class="weapon-button" onclick="changeWeapon('rasengan')">3 - RASENGAN</button>
        <button class="weapon-button" onclick="changeWeapon('kunai')">4 - KUNAI</button>
    </div>

    <div class="controls-info">
        <p>WSAD - Mover</p>
        <p>ESPA√áO - Jetpack</p>
        <p>Mouse - Apontar</p>
        <p>Click - Atirar</p>
        <p>G - Lan√ßar Kunai</p>
        <p>1/2/3/4 - Trocar Arma</p>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-content">
            <h1>GAME OVER</h1>
            <p>Pontos Finais: <span id="finalScore">0</span></p>
            <p>Zumbis Derrotados: <span id="killedZombies">0</span></p>
            <p>N√≠vel: <span id="finalDifficulty">NORMAL</span></p>
            <button onclick="location.reload()">Jogar Novamente</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configura√ß√£o b√°sica
        let currentDifficulty = 'normal';
        let difficultySettings = {
            easy: {
                spawnRate: 200,
                zombieSpeed: 0.03,
                zombieHealth: 1,
                maxZombies: 15,
                startLives: 5
            },
            normal: {
                spawnRate: 100,
                zombieSpeed: 0.05,
                zombieHealth: 1,
                maxZombies: 25,
                startLives: 3
            },
            hard: {
                spawnRate: 50,
                zombieSpeed: 0.08,
                zombieHealth: 2,
                maxZombies: 50,
                startLives: 2
            }
        };

        function startGame(difficulty) {
            currentDifficulty = difficulty;
            const settings = difficultySettings[difficulty];
            // Aguardar player estar definido
            if (player && player.health !== undefined) {
                player.health = settings.startLives;
                document.getElementById('difficulty').textContent = difficulty.toUpperCase();
                document.getElementById('finalDifficulty').textContent = difficulty.toUpperCase();
                document.getElementById('difficultyScreen').style.display = 'none';
                document.getElementById('lives').textContent = player.health;
            }
        }

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x4a4a4a, 150, 400);
        scene.background = new THREE.Color(0x5a5a5a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Ilumina√ß√£o - Vale do Fim escuro/nublado
        const ambientLight = new THREE.AmbientLight(0x8a8a8a, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xa0a0a0, 0.6);
        directionalLight.position.set(30, 40, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Piso - Vale do Fim (pedra/rocha)
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // √Ågua estilo Vale do Fim
        const waterGeometry = new THREE.PlaneGeometry(200, 50);
        const waterMaterial = new THREE.MeshLambertMaterial({ color: 0x1a4d5a, transparent: true, opacity: 0.7 });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = 0.05;
        water.position.z = -30;
        water.receiveShadow = true;
        scene.add(water);

        // Pared√µes rochosos laterais (lado esquerdo)
        const leftRockGeometry = new THREE.BoxGeometry(20, 80, 150);
        const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
        const leftRock = new THREE.Mesh(leftRockGeometry, rockMaterial);
        leftRock.position.x = -95;
        leftRock.position.y = 35;
        leftRock.castShadow = true;
        leftRock.receiveShadow = true;
        scene.add(leftRock);

        // Pared√µes rochosos laterais (lado direito)
        const rightRock = new THREE.Mesh(leftRockGeometry, rockMaterial);
        rightRock.position.x = 95;
        rightRock.position.y = 35;
        rightRock.castShadow = true;
        rightRock.receiveShadow = true;
        scene.add(rightRock);

        // Parede ao fundo (limite) - Pared√£o traseiro
        const wallGeometry = new THREE.BoxGeometry(200, 80, 15);
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.z = -100;
        wall.position.y = 35;
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);

        // Rochas decorativas (forma√ß√µes rochosas)
        function createRock(x, y, z, scale) {
            const rockGeom = new THREE.DodecahedronGeometry(scale, 2);
            const rockMesh = new THREE.Mesh(rockGeom, rockMaterial);
            rockMesh.position.set(x, y, z);
            rockMesh.castShadow = true;
            rockMesh.receiveShadow = true;
            scene.add(rockMesh);
        }

        createRock(-35, 2, -40, 3);
        createRock(35, 2, -40, 3);
        createRock(-50, 2, -60, 2);
        createRock(50, 2, -60, 2);
        createRock(0, 2, -80, 4);

        // Ru√≠nas de estruturas antigas
        function createRuin(x, y, z) {
            const ruinGroup = new THREE.Group();
            
            // Coluna antiga
            const columnGeom = new THREE.CylinderGeometry(0.8, 0.8, 8, 8);
            const rustMaterial = new THREE.MeshLambertMaterial({ color: 0x6b5d4f });
            const column = new THREE.Mesh(columnGeom, rustMaterial);
            column.castShadow = true;
            column.receiveShadow = true;
            ruinGroup.add(column);

            // Topo danificado
            const topGeom = new THREE.BoxGeometry(2, 0.5, 2);
            const top = new THREE.Mesh(topGeom, rustMaterial);
            top.position.y = 4.5;
            top.castShadow = true;
            top.receiveShadow = true;
            ruinGroup.add(top);

            ruinGroup.position.set(x, y, z);
            scene.add(ruinGroup);
        }

        createRuin(-20, 0, -20);
        createRuin(20, 0, -20);
        createRuin(0, 0, -50);

        // Est√°tuas Gigantes do Vale do Fim (tipo Indra e Asura)
        function createGiantStatue(x, z, color) {
            const statueGroup = new THREE.Group();

            // Cabe√ßa
            const headGeom = new THREE.BoxGeometry(8, 10, 6);
            const statueMaterial = new THREE.MeshLambertMaterial({ color: color });
            const head = new THREE.Mesh(headGeom, statueMaterial);
            head.position.y = 35;
            head.castShadow = true;
            head.receiveShadow = true;
            statueGroup.add(head);

            // Corpo
            const bodyGeom = new THREE.BoxGeometry(10, 20, 8);
            const body = new THREE.Mesh(bodyGeom, statueMaterial);
            body.position.y = 15;
            body.castShadow = true;
            body.receiveShadow = true;
            statueGroup.add(body);

            // Bra√ßo esquerdo
            const armGeom = new THREE.BoxGeometry(3, 15, 3);
            const armLeft = new THREE.Mesh(armGeom, statueMaterial);
            armLeft.position.set(-7, 15, 0);
            armLeft.castShadow = true;
            armLeft.receiveShadow = true;
            statueGroup.add(armLeft);

            // Bra√ßo direito
            const armRight = new THREE.Mesh(armGeom, statueMaterial);
            armRight.position.set(7, 15, 0);
            armRight.castShadow = true;
            armRight.receiveShadow = true;
            statueGroup.add(armRight);

            statueGroup.position.set(x, 0, z);
            scene.add(statueGroup);
        }

        createGiantStatue(-70, -80, 0x5a4a3a);
        createGiantStatue(70, -80, 0x4a5a6a);

        // √Årvores mortas/vegeta√ß√£o
        function createDeadTree(x, y, z) {
            const treeGroup = new THREE.Group();

            // Tronco
            const trunkGeom = new THREE.CylinderGeometry(0.5, 0.8, 6, 6);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            const trunk = new THREE.Mesh(trunkGeom, trunkMaterial);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);

            // Galhos
            for (let i = 0; i < 4; i++) {
                const branchGeom = new THREE.ConeGeometry(0.2, 3, 4);
                const branch = new THREE.Mesh(branchGeom, trunkMaterial);
                branch.position.y = 2.5 - i * 1;
                branch.rotation.z = Math.PI / 4 + (i * Math.PI / 6);
                branch.castShadow = true;
                branch.receiveShadow = true;
                treeGroup.add(branch);
            }

            treeGroup.position.set(x, y, z);
            scene.add(treeGroup);
        }

        createDeadTree(-40, 0, -10);
        createDeadTree(40, 0, -10);
        createDeadTree(-25, 0, 5);
        createDeadTree(25, 0, 5);

        // C√©u nublado
        const skyGeom = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x6a6a6a,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeom, skyMaterial);
        scene.add(sky);

        const player = {
            health: 3,
            position: new THREE.Vector3(0, 1, 15),
            direction: new THREE.Vector3(0, 0, -1),
            angle: 0,
            speed: 0.2,
            verticalVelocity: 0,
            jetpackActive: false,
            mesh: null
        };

        // Criar galinha com jetpack como jogador
        const playerGroup = new THREE.Group();

        // Corpo da galinha (esfera vermelha)
        const bodyGeom = new THREE.SphereGeometry(0.5, 32, 32);
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500 });
        const body = new THREE.Mesh(bodyGeom, bodyMaterial);
        body.scale.set(1, 1.2, 0.8);
        body.castShadow = true;
        body.receiveShadow = true;
        playerGroup.add(body);

        // Cabe√ßa da galinha (esfera amarela)
        const headGeom = new THREE.SphereGeometry(0.35, 32, 32);
        const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffa500 });
        const head = new THREE.Mesh(headGeom, headMaterial);
        head.position.set(0, 0.8, 0.3);
        head.castShadow = true;
        head.receiveShadow = true;
        playerGroup.add(head);

        // Bico (cone amarelo)
        const beakGeom = new THREE.ConeGeometry(0.15, 0.4, 8);
        const beak = new THREE.Mesh(beakGeom, headMaterial);
        beak.position.set(0, 0.8, 0.7);
        beak.rotation.x = Math.PI / 2;
        beak.castShadow = true;
        playerGroup.add(beak);

        // Olhos
        const eyeGeom = new THREE.SphereGeometry(0.08, 16, 16);
        const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeom, eyeMaterial);
        leftEye.position.set(-0.15, 0.95, 0.5);
        playerGroup.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeom, eyeMaterial);
        rightEye.position.set(0.15, 0.95, 0.5);
        playerGroup.add(rightEye);

        // Asas (ret√¢ngulos)
        const wingGeom = new THREE.BoxGeometry(0.3, 0.8, 0.15);
        const wingMaterial = new THREE.MeshPhongMaterial({ color: 0xdd4500 });
        
        const leftWing = new THREE.Mesh(wingGeom, wingMaterial);
        leftWing.position.set(-0.6, 0.4, 0);
        leftWing.rotation.z = Math.PI / 6;
        leftWing.castShadow = true;
        playerGroup.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeom, wingMaterial);
        rightWing.position.set(0.6, 0.4, 0);
        rightWing.rotation.z = -Math.PI / 6;
        rightWing.castShadow = true;
        playerGroup.add(rightWing);

        // Patas (cilindros marrom)
        const legGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8);
        const legMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
        
        const leftLeg = new THREE.Mesh(legGeom, legMaterial);
        leftLeg.position.set(-0.25, -0.65, 0);
        leftLeg.castShadow = true;
        playerGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeom, legMaterial);
        rightLeg.position.set(0.25, -0.65, 0);
        rightLeg.castShadow = true;
        playerGroup.add(rightLeg);

        // Jetpack (estrutura metalizada)
        const jetpackGroup = new THREE.Group();
        
        // Cilindros do jetpack (lado esquerdo)
        const jetpackCylinderGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
        const jetpackMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, shininess: 100 });
        
        const leftJetpack = new THREE.Mesh(jetpackCylinderGeom, jetpackMaterial);
        leftJetpack.position.set(-0.4, -0.3, 0);
        leftJetpack.castShadow = true;
        jetpackGroup.add(leftJetpack);

        // Cilindros do jetpack (lado direito)
        const rightJetpack = new THREE.Mesh(jetpackCylinderGeom, jetpackMaterial);
        rightJetpack.position.set(0.4, -0.3, 0);
        rightJetpack.castShadow = true;
        jetpackGroup.add(rightJetpack);

        // Fuel tank (caixa grande atr√°s)
        const fuelTankGeom = new THREE.BoxGeometry(0.6, 0.6, 0.3);
        const fuelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const fuelTank = new THREE.Mesh(fuelTankGeom, fuelMaterial);
        fuelTank.position.set(0, -0.2, -0.5);
        fuelTank.castShadow = true;
        jetpackGroup.add(fuelTank);

        jetpackGroup.position.set(0, -0.5, 0);
        playerGroup.add(jetpackGroup);

        player.mesh = playerGroup;
        player.mesh.position.copy(player.position);
        scene.add(player.mesh);

        // Part√≠culas de chama do jetpack
        let jetpackParticles = [];

        function createJetpackFlame() {
            const flameGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.5)
            });
            const flame = new THREE.Mesh(flameGeom, flameMaterial);
            
            const offset = (Math.random() - 0.5) * 0.4;
            flame.position.set(
                player.position.x + offset,
                player.position.y - 1,
                player.position.z + (Math.random() - 0.5) * 0.3
            );
            
            scene.add(flame);
            
            jetpackParticles.push({
                mesh: flame,
                life: 15,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    -0.3 - Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.1
                )
            });
        }

        // C√¢mera segue jogador
        camera.position.copy(player.position);
        camera.position.y = 3;

        let bullets = [];
        let zombies = [];
        let grenades = [];
        let gameRunning = true;
        let score = 0;
        let killedZombies = 0;
        let currentWeapon = 'pistol';
        let grenadesCount = Infinity;

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toUpperCase()] = true;
            if (e.key === 'g' || e.key === 'G') throwGrenade();
            if (e.key === '1') changeWeapon('pistol');
            if (e.key === '2') changeWeapon('bow');
            if (e.key === '3') changeWeapon('rasengan');
            if (e.key === '4') changeWeapon('kunai');
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toUpperCase()] = false;
        });

        document.addEventListener('mousemove', (e) => {
            const deltaX = e.movementX || 0;
            player.angle -= deltaX * 0.01;
            player.direction.x = Math.sin(player.angle);
            player.direction.z = Math.cos(player.angle);
        });

        document.addEventListener('click', shoot);

        function changeWeapon(weapon) {
            currentWeapon = weapon;
            document.querySelectorAll('.weapon-button').forEach(btn => btn.classList.remove('active'));
            
            // Encontrar o √≠ndice da arma e destacar o bot√£o correto
            const weaponMap = {
                'pistol': 0,
                'bow': 1,
                'rasengan': 2,
                'kunai': 3
            };
            
            const buttons = document.querySelectorAll('.weapon-button');
            if (buttons[weaponMap[weapon]]) {
                buttons[weaponMap[weapon]].classList.add('active');
            }
            
            const weaponNames = {
                'pistol': 'PISTOLA',
                'bow': 'ARCO',
                'rasengan': 'RASENGAN',
                'kunai': 'KUNAI'
            };
            document.getElementById('weaponName').textContent = weaponNames[weapon];
        }

        function shoot() {
            if (!gameRunning || currentWeapon === 'kunai') return;

            let bulletGeometry, bulletMaterial, speed, damage, bulletSize;

            if (currentWeapon === 'pistol') {
                bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                bulletMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
                speed = 0.8;
                damage = 1;
            } else if (currentWeapon === 'bow') {
                bulletGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                bulletMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 });
                speed = 0.6;
                damage = 2;
            } else if (currentWeapon === 'rasengan') {
                bulletGeometry = new THREE.SphereGeometry(0.35, 32, 32);
                bulletMaterial = new THREE.MeshPhongMaterial({ color: 0x0099ff, emissive: 0x0066ff });
                speed = 0.9;
                damage = 4;
            }

            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

            const startPos = player.position.clone();
            startPos.y = player.position.y + 0.5;
            startPos.addScaledVector(player.direction, 1);

            bullet.position.copy(startPos);
            bullet.castShadow = true;
            scene.add(bullet);

            bullets.push({
                mesh: bullet,
                position: bullet.position,
                direction: player.direction.clone(),
                speed: speed,
                damage: damage,
                life: 500
            });
        }

        function throwGrenade() {
            if (!gameRunning) return;

            // Criar Kunai com visual de faca/l√¢mina
            const kunaiGroup = new THREE.Group();
            
            // Ponta
            const kunaiPointGeometry = new THREE.ConeGeometry(0.08, 0.2, 4);
            const kunaiMaterial = new THREE.MeshPhongMaterial({ color: 0xc0c0c0, shininess: 100 });
            const kunaiPoint = new THREE.Mesh(kunaiPointGeometry, kunaiMaterial);
            kunaiPoint.position.z = 0.1;
            kunaiGroup.add(kunaiPoint);
            
            // Corpo
            const kunaiBodyGeometry = new THREE.BoxGeometry(0.06, 0.15, 0.4);
            const kunaiBody = new THREE.Mesh(kunaiBodyGeometry, kunaiMaterial);
            kunaiGroup.add(kunaiBody);
            
            // Al√ßa (vermelha)
            const kunaiHandleGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.08);
            const kunaiHandleMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const kunaiHandle = new THREE.Mesh(kunaiHandleGeometry, kunaiHandleMaterial);
            kunaiHandle.position.z = -0.15;
            kunaiGroup.add(kunaiHandle);
            
            const startPos = player.position.clone();
            startPos.y = player.position.y + 0.5;
            startPos.addScaledVector(player.direction, 1);

            kunaiGroup.position.copy(startPos);
            kunaiGroup.castShadow = true;
            scene.add(kunaiGroup);

            const speed = 0.6;
            const velocity = player.direction.clone().multiplyScalar(speed);
            velocity.y = 0.2;

            grenades.push({
                mesh: kunaiGroup,
                position: kunaiGroup.position,
                velocity: velocity,
                life: 200,
                exploded: false
            });
        }

        function spawnZombie() {
            const settings = difficultySettings[currentDifficulty];
            if (zombies.length >= settings.maxZombies) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = 50 + Math.random() * 30;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            // Criar zumbi com visual Naruto (usando TextCanvas)
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Desenhar Naruto estilizado
            ctx.fillStyle = '#ffb347';
            ctx.fillRect(30, 10, 68, 50); // Cabe√ßa
            ctx.fillStyle = '#ffa500';
            ctx.fillRect(40, 20, 18, 18); // Olho esquerdo
            ctx.fillRect(70, 20, 18, 18); // Olho direito
            ctx.fillStyle = '#000';
            ctx.fillRect(42, 22, 8, 8); // Pupila esquerda
            ctx.fillRect(72, 22, 8, 8); // Pupila direita
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(50, 50, 28, 8); // Marca Naruto
            ctx.fillStyle = '#ff7f50';
            ctx.fillRect(20, 60, 88, 50); // Corpo
            ctx.fillStyle = '#ffa500';
            ctx.fillRect(15, 90, 15, 30); // Bra√ßo esquerdo
            ctx.fillRect(98, 90, 15, 30); // Bra√ßo direito

            const texture = new THREE.CanvasTexture(canvas);
            const zombieGeometry = new THREE.BoxGeometry(0.8, 2, 0.6);
            const zombieMaterial = new THREE.MeshPhongMaterial({ map: texture });
            const zombie = new THREE.Mesh(zombieGeometry, zombieMaterial);

            zombie.position.set(x, 1, z);
            zombie.castShadow = true;
            scene.add(zombie);

            zombies.push({
                mesh: zombie,
                position: zombie.position,
                health: settings.zombieHealth,
                speed: settings.zombieSpeed
            });

            document.getElementById('zombies').textContent = zombies.length;
        }

        function updatePlayer() {
            const moveDirection = new THREE.Vector3();
            if (keys['W']) moveDirection.addScaledVector(player.direction, player.speed);
            if (keys['S']) moveDirection.addScaledVector(player.direction, -player.speed);
            if (keys['A']) {
                const left = new THREE.Vector3(-player.direction.z, 0, player.direction.x);
                moveDirection.addScaledVector(left, player.speed);
            }
            if (keys['D']) {
                const right = new THREE.Vector3(player.direction.z, 0, -player.direction.x);
                moveDirection.addScaledVector(right, player.speed);
            }

            // Sistema de Jetpack
            if (keys[' ']) {  // Espa√ßo para ativar jetpack
                player.jetpackActive = true;
                player.verticalVelocity = 0.25;  // Propuls√£o para cima
                
                // Gerar chamas do jetpack
                for (let i = 0; i < 2; i++) {
                    createJetpackFlame();
                }
            } else {
                player.jetpackActive = false;
            }

            // Aplicar gravidade
            if (!player.jetpackActive) {
                player.verticalVelocity -= 0.015;  // Gravidade
            }

            // Limitar velocidade vertical
            if (player.verticalVelocity > 0.3) player.verticalVelocity = 0.3;
            if (player.verticalVelocity < -0.5) player.verticalVelocity = -0.5;

            // Aplicar movimento vertical
            player.position.y += player.verticalVelocity;

            // Colis√£o com o ch√£o
            if (player.position.y < 1) {
                player.position.y = 1;
                player.verticalVelocity = 0;
            }

            // Limite de altura
            if (player.position.y > 50) {
                player.position.y = 50;
                player.verticalVelocity = 0;
            }

            player.position.add(moveDirection);
            player.mesh.position.copy(player.position);

            // Girar a galinha na dire√ß√£o do movimento
            player.mesh.rotation.y = player.angle + Math.PI;

            // Limites da √°rea
            if (player.position.x < -90) player.position.x = -90;
            if (player.position.x > 90) player.position.x = 90;
            if (player.position.z < -90) player.position.z = -90;
            if (player.position.z > 90) player.position.z = 90;

            // Atualizar part√≠culas do jetpack
            for (let i = jetpackParticles.length - 1; i >= 0; i--) {
                const particle = jetpackParticles[i];
                particle.mesh.position.addScaledVector(particle.velocity, 1);
                particle.life--;

                particle.mesh.scale.set(
                    1 - (15 - particle.life) / 15,
                    1 - (15 - particle.life) / 15,
                    1 - (15 - particle.life) / 15
                );

                if (particle.life <= 0) {
                    scene.remove(particle.mesh);
                    jetpackParticles.splice(i, 1);
                }
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.addScaledVector(bullet.direction, bullet.speed);
                bullet.life--;

                if (bullet.life < 0 || bullet.position.length() > 150) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                    continue;
                }

                // Colis√£o com zumbis
                for (let j = zombies.length - 1; j >= 0; j--) {
                    const zombie = zombies[j];
                    const dist = bullet.position.distanceTo(zombie.position);
                    if (dist < 1.5) {
                        zombie.health -= bullet.damage;
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);

                        if (zombie.health <= 0) {
                            scene.remove(zombie.mesh);
                            zombies.splice(j, 1);
                            score += 10;
                            killedZombies++;
                        }
                        break;
                    }
                }
            }
        }

        function updateGrenades() {
            for (let i = grenades.length - 1; i >= 0; i--) {
                const grenade = grenades[i];
                grenade.position.addScaledVector(grenade.velocity, 1);
                grenade.velocity.y -= 0.01; // Gravidade
                grenade.life--;

                // Explodir no ch√£o
                if (grenade.position.y <= 0.2 || grenade.life <= 0) {
                    if (!grenade.exploded) {
                        grenade.exploded = true;

                        // Dano em √°rea
                        for (let j = zombies.length - 1; j >= 0; j--) {
                            const zombie = zombies[j];
                            const dist = grenade.position.distanceTo(zombie.position);
                            if (dist < 8) {
                                zombie.health -= 3;
                                if (zombie.health <= 0) {
                                    scene.remove(zombie.mesh);
                                    zombies.splice(j, 1);
                                    score += 15;
                                    killedZombies++;
                                }
                            }
                        }

                        // Efeito visual
                        const explosionGeometry = new THREE.SphereGeometry(6, 8, 8);
                        const explosionMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                        explosion.position.copy(grenade.position);
                        scene.add(explosion);

                        setTimeout(() => scene.remove(explosion), 100);
                    }
                    scene.remove(grenade.mesh);
                    grenades.splice(i, 1);
                }
            }
        }

        function updateZombies() {
            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                const direction = new THREE.Vector3().subVectors(player.position, zombie.position).normalize();
                zombie.position.addScaledVector(direction, zombie.speed);
                zombie.mesh.position.copy(zombie.position);

                // Rotacionar para olhar para o jogador
                zombie.mesh.lookAt(player.position);

                // Colis√£o com jogador
                if (player.position.distanceTo(zombie.position) < 1.5) {
                    player.health--;
                    document.getElementById('lives').textContent = player.health;
                    scene.remove(zombie.mesh);
                    zombies.splice(i, 1);

                    if (player.health <= 0) {
                        gameRunning = false;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('killedZombies').textContent = killedZombies;
                        document.getElementById('gameOverScreen').style.display = 'flex';
                    }
                }
            }

            document.getElementById('score').textContent = score;
            document.getElementById('zombies').textContent = zombies.length;
        }

        let spawnTimer = 0;

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            if (gameRunning) {
                updatePlayer();
                updateBullets();
                updateGrenades();
                updateZombies();

                const settings = difficultySettings[currentDifficulty];
                spawnTimer++;
                if (spawnTimer > settings.spawnRate) {
                    spawnZombie();
                    spawnTimer = 0;
                }
            }

            // C√¢mera em terceira pessoa atr√°s do jogador - Segue jetpack
            let cameraDistance = 8;
            let cameraHeight = player.position.y + 2.5;
            let cameraSpeed = 0.15;

            // Quando jetpack est√° ativo, c√¢mera segue mais de perto e mais alto
            if (player.jetpackActive) {
                cameraDistance = 6;  // Mais perto quando voa
                cameraHeight = player.position.y + 3.5;  // Mais alto para ver melhor
                cameraSpeed = 0.2;  // Mais r√°pido para acompanhar
            } else {
                // Suavizar retorno √† posi√ß√£o normal
                cameraDistance = 8;
                cameraHeight = player.position.y + 2.5;
                cameraSpeed = 0.15;
            }

            const targetCamPos = new THREE.Vector3().copy(player.position);
            targetCamPos.y = cameraHeight;
            targetCamPos.addScaledVector(player.direction, -cameraDistance);
            
            // Movimento suave da c√¢mera
            camera.position.x += (targetCamPos.x - camera.position.x) * cameraSpeed;
            camera.position.y += (targetCamPos.y - camera.position.y) * cameraSpeed;
            camera.position.z += (targetCamPos.z - camera.position.z) * cameraSpeed;
            
            // C√¢mera sempre olha para o personagem
            camera.lookAt(player.position.clone().setY(player.position.y + 1));

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Iniciar
        gameLoop();
    </script>
</body>
</html>
